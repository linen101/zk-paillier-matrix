use paillier::{EncryptionKey, Paillier, KeyGeneration};
use curv::arithmetic::traits::*;
use curv::BigInt;


fn gen_keys() -> EncryptionKey {
    let (ek, _) = Paillier::keypair().keys();
    ek
}

// Generate two elements g and h in Z_N^*, ensuring that g is in the group generated by h.
fn gen_g_h(ek: &EncryptionKey) -> (BigInt, BigInt) {
    let n = ek.n.clone();
    
    // Generate h âˆˆ Z_N^*
    let h = BigInt::sample_below(&n);
    
    // Generate g as a random power of h, g = h^x mod N, where x is random
    let x = BigInt::sample_below(&n);
    let g = BigInt::mod_pow(&h, &x, &n);  // g = h^x mod N

    (g, h)
}


pub struct Commitment {
    m: BigInt,
    r: BigInt,  // The random blinding factor used in the commitment
}

pub struct PublicParamsCom {
    g: BigInt,
    h: BigInt,
    n: BigInt,
}

impl Commitment {
// Commitment function: Com(m, r) = g^m h^r mod N
    fn commitment(com: &Commitment, pp: &PublicParamsCom) -> BigInt {
        let gm = BigInt::mod_pow(&pp.g, &com.m, &pp.n);  // g^m mod N
        let hr = BigInt::mod_pow(&pp.h, &com.r, &pp.n);  // h^r mod N
        let com = BigInt::mod_pow(&gm, &hr, &pp.n);

        com
    }
}
#[cfg(test)]
mod tests {
    use curv::arithmetic::traits::*;
    use curv::BigInt;

    use crate::zkproofs::fujisaki_okamoto_commitment::gen_keys;
    use crate::zkproofs::fujisaki_okamoto_commitment::gen_g_h;
    use crate::zkproofs::fujisaki_okamoto_commitment::Commitment;
    use crate::zkproofs::fujisaki_okamoto_commitment::PublicParamsCom;

    #[test]
    fn test_com() {
        // Key generation
        let ek = gen_keys();
        
        // Generate g and h
        let (g, h) = gen_g_h(&ek);
        
        // Example message m and random value r
        let m = BigInt::from(42);  // Example message
        let r = BigInt::sample_below(&ek.n);  // Random value
        
        let com = Commitment{
            m : m.clone(),
            r : r.clone(),
        };

        let pp = PublicParamsCom{
            g : g.clone(),
            h : h.clone(),
            n : ek.n.clone(),
        };
        // Compute the commitment
        let com = Commitment::commitment(&com, &pp);
        
        println!("Commitment: {},{}", com, m);
    }
}